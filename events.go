package ldevents

import (
	"encoding/json"

	"gopkg.in/launchdarkly/go-sdk-common.v3/ldcontext"
	"gopkg.in/launchdarkly/go-sdk-common.v3/ldreason"
	"gopkg.in/launchdarkly/go-sdk-common.v3/ldtime"
	"gopkg.in/launchdarkly/go-sdk-common.v3/ldvalue"
)

// EventContext is a combination of the standard Context struct with additional information that
// may be relevant outside of the standard SDK event generation context.
//
// Specifically, this is because ld-relay uses go-sdk-events to post-process events it has
// received from the PHP SDK. In this scenario the PHP SDK will have already applied the
// private-attribute-redaction logic, so if a context in an event already has its "redactedAttributes"
// property set, we want to pass that property straight through and skip our usual redaction logic.
//
// That requirement is specific to ld-relay. In regular usage of the Go SDK, we always just use the
// plain Context constructor which does not support pre-redacted attributes.
type EventContext struct {
	context     ldcontext.Context
	preRedacted bool
}

// Context creates an EventContext that is exactly equivalent to the given Context.
func Context(context ldcontext.Context) EventContext {
	return EventContext{context: context}
}

// ContextPreRedacted creates an EventContext that wraps the given Context, additionally
// indicating that the private attributes list in this context (or, for a multi-kind
// context, the private attributes list in each individual subcontext) is really a list of
// attributes that were *already* redacted, rather than ones that should be redacted. This is
// used in ld-relay.
func ContextPreRedacted(context ldcontext.Context) EventContext {
	return EventContext{context: context, preRedacted: true}
}

// Event represents an analytics event generated by the client, which will be passed to
// the EventProcessor.  The event data that the EventProcessor actually sends to LaunchDarkly
// may be slightly different.
type Event interface {
	GetBase() BaseEvent
}

// commonEvent is a less restrictive alternative to Event that does not require a User to satisfy.
type commonEvent interface {
	GetCreationDate() ldtime.UnixMillisecondTime
}

// BaseEvent provides properties common to all events.
type BaseEvent struct {
	CreationDate ldtime.UnixMillisecondTime
	Context      EventContext
}

// FeatureRequestEvent is generated by evaluating a feature flag or one of a flag's prerequisites.
type FeatureRequestEvent struct {
	BaseEvent
	Key                  string
	Variation            ldvalue.OptionalInt
	Value                ldvalue.Value
	Default              ldvalue.Value
	Version              ldvalue.OptionalInt
	PrereqOf             ldvalue.OptionalString
	Reason               ldreason.EvaluationReason
	TrackEvents          bool
	Debug                bool
	DebugEventsUntilDate ldtime.UnixMillisecondTime
}

// CustomEvent is generated by calling the client's Track method.
type CustomEvent struct {
	BaseEvent
	Key         string
	Data        ldvalue.Value
	HasMetric   bool
	MetricValue float64
}

// IdentifyEvent is generated by calling the client's Identify method.
type IdentifyEvent struct {
	BaseEvent
}

// indexEvent is generated internally to capture user details from other events. It is an implementation
// detail of DefaultEventProcessor, so it is not exported.
type indexEvent struct {
	BaseEvent
}

// rawEvent is used internally when the Relay Proxy needs to inject a JSON event into the outbox that
// will be sent exactly as is with no processing.
type rawEvent struct {
	data json.RawMessage
}

// EventFactory is a configurable factory for event objects.
type EventFactory struct {
	includeReasons bool
	timeFn         func() ldtime.UnixMillisecondTime
}

// NewEventFactory creates an EventFactory.
//
// The includeReasons parameter is true if evaluation events should always include the EvaluationReason (this is
// used by the SDK when one of the "VariationDetail" methods is called). The timeFn parameter is normally nil but
// can be used to instrument the EventFactory with a source of time data other than the standard clock.
//
// The isExperimentFn parameter is necessary to provide the additional experimentation behavior that is
func NewEventFactory(includeReasons bool, timeFn func() ldtime.UnixMillisecondTime) EventFactory {
	if timeFn == nil {
		timeFn = ldtime.UnixMillisNow
	}
	return EventFactory{includeReasons, timeFn}
}

// NewUnknownFlagEvent creates an evaluation event for a missing flag.
func (f EventFactory) NewUnknownFlagEvent(
	key string,
	context EventContext,
	defaultVal ldvalue.Value,
	reason ldreason.EvaluationReason,
) FeatureRequestEvent {
	fre := FeatureRequestEvent{
		BaseEvent: BaseEvent{
			CreationDate: f.timeFn(),
			Context:      context,
		},
		Key:     key,
		Value:   defaultVal,
		Default: defaultVal,
	}
	if f.includeReasons {
		fre.Reason = reason
	}
	return fre
}

// NewEvalEvent creates an evaluation event for an existing flag.
func (f EventFactory) NewEvalEvent(
	flagProps FlagEventProperties,
	context EventContext,
	detail ldreason.EvaluationDetail,
	defaultVal ldvalue.Value,
	prereqOf string,
) FeatureRequestEvent {
	requireExperimentData := flagProps.IsExperimentationEnabled(detail.Reason)
	fre := FeatureRequestEvent{
		BaseEvent: BaseEvent{
			CreationDate: f.timeFn(),
			Context:      context,
		},
		Key:                  flagProps.GetKey(),
		Version:              ldvalue.NewOptionalInt(flagProps.GetVersion()),
		Variation:            detail.VariationIndex,
		Value:                detail.Value,
		Default:              defaultVal,
		TrackEvents:          requireExperimentData || flagProps.IsFullEventTrackingEnabled(),
		DebugEventsUntilDate: flagProps.GetDebugEventsUntilDate(),
	}
	if f.includeReasons || requireExperimentData {
		fre.Reason = detail.Reason
	}
	if prereqOf != "" {
		fre.PrereqOf = ldvalue.NewOptionalString(prereqOf)
	}
	return fre
}

// GetBase returns the BaseEvent
func (evt FeatureRequestEvent) GetBase() BaseEvent {
	return evt.BaseEvent
}

// GetCreationDate returns CreationDate
func (evt FeatureRequestEvent) GetCreationDate() ldtime.UnixMillisecondTime {
	return evt.BaseEvent.CreationDate
}

// NewCustomEvent creates a new custom event.
func (f EventFactory) NewCustomEvent(
	key string,
	context EventContext,
	data ldvalue.Value,
	withMetric bool,
	metricValue float64,
) CustomEvent {
	ce := CustomEvent{
		BaseEvent: BaseEvent{
			CreationDate: f.timeFn(),
			Context:      context,
		},
		Key:         key,
		Data:        data,
		HasMetric:   withMetric,
		MetricValue: metricValue,
	}
	return ce
}

// GetBase returns the BaseEvent
func (evt CustomEvent) GetBase() BaseEvent {
	return evt.BaseEvent
}

// GetCreationDate returns CreationDate
func (evt CustomEvent) GetCreationDate() ldtime.UnixMillisecondTime {
	return evt.BaseEvent.CreationDate
}

// NewIdentifyEvent constructs a new identify event, but does not send it. Typically, Identify should be
// used to both create the event and send it to LaunchDarkly.
func (f EventFactory) NewIdentifyEvent(context EventContext) IdentifyEvent {
	return IdentifyEvent{
		BaseEvent: BaseEvent{
			CreationDate: f.timeFn(),
			Context:      context,
		},
	}
}

// GetBase returns the BaseEvent
func (evt IdentifyEvent) GetBase() BaseEvent {
	return evt.BaseEvent
}

// GetCreationDate returns CreationDate
func (evt IdentifyEvent) GetCreationDate() ldtime.UnixMillisecondTime {
	return evt.BaseEvent.CreationDate
}

// GetBase returns the BaseEvent
func (evt indexEvent) GetBase() BaseEvent {
	return evt.BaseEvent
}

// GetCreationDate returns CreationDate
func (evt indexEvent) GetCreationDate() ldtime.UnixMillisecondTime {
	return evt.BaseEvent.CreationDate
}

// GetCreationDate for a rawEvent is meaningless but is required by the commonEvent interface
func (evt rawEvent) GetCreationDate() ldtime.UnixMillisecondTime {
	return 0
}
